# AZT607.1 - Extract Azure Load Testing Secrets and Tokens: JMeter/Locust Code Execution

**Resource**  
Azure Load Testing

**Summary**

Azure Load Testing supports uploading JMeter **JMX** or **Locust** test scripts. JMX allows embedded objects such as **JSR223Sampler** (Groovy) or **BeanShell**, and Locust scripts are standard Python. When these tests execute, the worker process can access:

- **Managed Identity** tokens via the Instance Metadata Service (IMDS) for the Load Testing resource’s assigned MI.
- **Secrets** injected as **environment variables** for the test (for example, API keys/credentials passed as parameters).
- **Certificates** provided to the test runner (stored on disk).

**Known default locations (as documented by research and Microsoft docs)**

- Secrets: exposed to the test as **environment variables**.
- Certificates (Locust): path indicated by the `ALT_CERTIFICATES_DIR` environment variable (commonly `/root/artifacts/certs/`).
- Certificates (JMeter): typically under `/jmeter/bin/` within the runner container.

**Permissions / Preconditions**

- Ability to create or modify and run tests in the target Azure Load Testing resource (e.g., **Contributor** on the resource or equivalent delegated access). Exact role requirements depend on tenant configuration.
- Managed Identity must be enabled to obtain MI tokens (if token extraction is a goal).
- Secrets/certificates must be configured for the tests (if secret extraction is a goal).

**Procedure (High Level)**

1. **Prepare malicious test content**:  
   - JMeter: add a `JSR223Sampler` executing Groovy to run commands and read env/files (e.g., `whoami`, reading env vars, listing cert paths).  
   - Locust: embed Python code to read env/files and make HTTP requests.
2. **Execute in Azure Load Testing**: upload and run the test in the target resource.
3. **Extract data**:
   - Enumerate environment variables and read certificate files.  
   - Query IMDS for a token using the resource’s Managed Identity (standard Azure IMDS endpoint).  
   - If HTTP responses aren’t directly observable in results, use the approach from research: start a local HTTP listener within the worker and have the test send requests to it so that outputs appear in the **test results zip** collected by the service.
4. **Collect artifacts**: download the **results zip** from the run and parse the CSV/logs to recover exfiltrated data; optionally save certificate files.

**Automation Example (Public Tooling)**

- **MicroBurst** function `Get-AzLoadTestingData` automates: enumeration of Load Testing resources and tests; scraping test settings for secrets/certificates/variables; creating a new test; running a data collection routine; downloading and parsing the results zip; and optional saving of certificates.

**Detections**

*Notes*: The Microsoft **Activity Log** did **not** provide sufficient telemetry in testing; enabling **Diagnostic Logs** for Azure Load Testing was required to observe relevant operations. The following operation names/IDs were observed by researchers (names may evolve; validate in your tenant):

Data Source | Indicator | Operation / Details
---|---|---
Azure Load Testing Diagnostic Logs | Listing tests | `MICROSOFT.LOADTESTSERVICE/LOADTESTS/READTEST/ACTION` (`LoadTestAdministration_ListTests`, `GET`)
Azure Load Testing Diagnostic Logs | Reading test details | `MICROSOFT.LOADTESTSERVICE/LOADTESTS/READTEST/ACTION` (`LoadTestAdministration_GetTest`, `GET`)
Azure Load Testing Diagnostic Logs | Deleting a test (cleanup) | `MICROSOFT.LOADTESTSERVICE/LOADTESTS/DELETETEST/ACTION` (`LoadTestAdministration_DeleteTest`, `DELETE`)
Azure Load Testing Diagnostic Logs | Results ZIP retrieval | **Not logged** in research notes (URL is external but referenced in GetTest output)

*Query ideas (adjust table names to your workspace schema)*

```text
-- Example pseudo-KQL: search Load Testing Diagnostic Logs for suspicious test admin activity
LoadTestingDiagnostics
| where OperationName has_any ("READTEST", "DELETETEST")
| project TimeGenerated, OperationName, OperationId, RequestUri, Caller, _ResourceId
```

**Mitigations**

- **Least privilege**: restrict who can create/modify tests on Azure Load Testing; avoid broad Contributor on the resource.
- **Secrets hygiene**: prefer short-lived credentials; use Key Vault references and scope MI permissions minimally; rotate secrets regularly.
- **Network and policy controls**: consider **private network injection** for Load Testing and limit egress; use **Azure Policy** to audit/deny risky configurations (e.g., enforcing private endpoints for tests as applicable).
- **Logging**: enable **Diagnostic Settings** for Azure Load Testing to Log Analytics and alert on unusual test creation/reads and unexpected test content.

**Additional Resources**

- NetSPI: *Extracting Sensitive Information from Azure Load Testing* – https://www.netspi.com/blog/technical-blog/cloud-pentesting/extracting-sensitive-information-azure-load-testing/
- MicroBurst `Get-AzLoadTestingData` – https://github.com/NetSPI/MicroBurst/blob/master/Az/Get-AzLoadTestingData.ps1
- Microsoft Docs: *Use secrets & environment variables in Azure Load Testing* – https://learn.microsoft.com/azure/app-testing/load-testing/how-to-parameterize-load-tests
- Microsoft Docs: *Load test authenticated endpoints* – https://learn.microsoft.com/azure/app-testing/load-testing/how-to-test-secured-endpoints
- Microsoft Docs: *Use Azure Policy with Azure Load Testing* – https://learn.microsoft.com/azure/app-testing/load-testing/how-to-use-azure-policy
